
# Лабораторная работа № 2

Аганин Егор Владимирович

**Вариант:** rb-tree, dict, lazy.

## Требования к выполняемой работе

Функции:

- Добавление и удаление элементов
- Фильтрация
- Отображение (map)
- Свертки (левая и правая)

### Структура данных

- Структура должна быть моноидом.
- Данные должна быть неизменяемой.
- Библиотека должна быть протестирована в рамках unit-testing.
- Библиотека должна быть протестирована в рамках property-based тестирования (как минимум 3 свойства, включая свойства моноида).
- Структура данных должна быть полиморфной.
- Требуется использовать идиоматичный для технологии стиль программирования.

## Реализация

- Структура Red-Black Tree реализована в файле [RBTree.hs](https://github.com/b4wb0le1l0/FuncProg2/blob/main/src/RBTree.hs)
- Интерфейс Dict реализован в файле [Dict.hs](https://github.com/b4wb0le1l0/FuncProg2/blob/main/src/Dict.hs)

## Примеры ленивых вычислений в коде

### Функции foldl'' и foldr''

```haskell
foldr'' _ acc Leaf = acc
foldr'' f acc (Node {key = k, value = vl, leftChild = left, rightChild = right}) = 
    foldr'' f (f (k, vl) (foldr'' f acc right)) left
```

- Эти функции реализуют сворачивания, которые используют ленивый обход структуры данных. Например, в foldr'' элементы обрабатываются по мере их обработки. foldr'' не обходит левое поддерево сразу, а будет вызывать функцию только тогда, когда она будет нужна в значениях из этого левого поддерева.

### Функция filter'

```Haskell
filter' p = foldr'' ( $ k, vl) d -> if p vl then insert' k vl d else d) (fromList' [])
```

- Фильтр использует foldr'', чтобы, очевидно, фильтровать элементы.То есть элементы добавляются в результирующий словарь только по мере их прохождения. Как только элемент(vl) не проходит условие(p), вычисления для этого элемента прекращаются.

### Функция fromList'

```Haskell
fromList' ls = go ls Leaf
  where
    go [] d = d
    go (x : xs) d = go xs $ uncurry insert' x d
```

- Рекурсивно обрабатываем список пар (a, b). И insert' здесь вызывается только тогда, когда пара со значением (x, v) обрабатывается. Если список (ls) окажется очень большим, (go) не будет пытаться вставить элементы в дерево, которое в свою очередь не будет использоваться.
Следовательно, вставка происходит постепенно, и значения будут обрабатываться полностью только в случае, когда они действительно передаются в (insert').

### Функция lookup'

```Haskell
lookup' _ Leaf = Nothing
lookup' a Node {key = nk, value = vl, leftChild = left, rightChild = right}
  | a == nk = Just vl
  | a < nk  = lookup' a left
  | otherwise = lookup' a right
```

- Здесь так же мы можем наблюдать "ленивость". Когда узел дерева не является листом, поиск будет только в соответствующей ветви. Однако, когда ключ найден, дальнейшие вычисления не происходят.
